<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Using Transport Layer Security (TLS) to Secure QUIC</title>

  <style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    padding: 0 1em;
    z-index: 1;
  }
  #rfc\.toc {
    top: 16px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
  }

  body {
    padding-left: 1.5em;
    padding-right: 29em;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 2.5em auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc, ul.toc ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>

  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Notational Conventions"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Protocol Overview"/>
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Handshake Overview"/>
<link href="#rfc.section.3" rel="Chapter" title="3 TLS in Stream 1"/>
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Handshake and Setup Sequence"/>
<link href="#rfc.section.4" rel="Chapter" title="4 QUIC Record Protection"/>
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Key Phases"/>
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 QUIC Key Expansion"/>
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 QUIC AEAD application"/>
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 Sequence Number Reconstruction"/>
<link href="#rfc.section.5" rel="Chapter" title="5 Pre-handshake QUIC Messages"/>
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Unprotected Frames Prior to Handshake Completion"/>
<link href="#rfc.section.5.1.1" rel="Chapter" title="5.1.1 STREAM Frames"/>
<link href="#rfc.section.5.1.2" rel="Chapter" title="5.1.2 ACK Frames"/>
<link href="#rfc.section.5.1.3" rel="Chapter" title="5.1.3 WINDOW_UPDATE Frames"/>
<link href="#rfc.section.5.1.4" rel="Chapter" title="5.1.4 FEC Packets"/>
<link href="#rfc.section.5.1.5" rel="Chapter" title="5.1.5 Denial of Service with Unprotected Packets"/>
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Use of 0-RTT Keys"/>
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Protected Frames Prior to Handshake Completion"/>
<link href="#rfc.section.6" rel="Chapter" title="6 QUIC-Specific Additions to the TLS Handshake"/>
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Protocol and Version Negotiation"/>
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 QUIC Extension"/>
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Source Address Validation"/>
<link href="#rfc.section.6.4" rel="Chapter" title="6.4 Packet Reflection Attack Mitigation"/>
<link href="#rfc.section.7" rel="Chapter" title="7 Security Considerations"/>
<link href="#rfc.section.8" rel="Chapter" title="8 IANA Considerations"/>
<link href="#rfc.references" rel="Chapter" title="9 References"/>
<link href="#rfc.references.1" rel="Chapter" title="9.1 Normative References"/>
<link href="#rfc.references.2" rel="Chapter" title="9.2 Informative References"/>
<link href="#rfc.appendix.A" rel="Chapter" title="A Acknowledgments"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.1 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Thomson, M. and R. Hamilton" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-thomson-quic-tls-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2016-5-24" />
  <meta name="dct.abstract" content="This document describes how Transport Layer Security (TLS) can be used to secure QUIC." />
  <meta name="description" content="This document describes how Transport Layer Security (TLS) can be used to secure QUIC." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">Network Working Group</td>
  <td class="right">M. Thomson</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">Mozilla</td>
</tr>
<tr>
  <td class="left">Intended status: Standards Track</td>
  <td class="right">R. Hamilton</td>
</tr>
<tr>
  <td class="left">Expires: November 25, 2016</td>
  <td class="right">Google</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">May 24, 2016</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Using Transport Layer Security (TLS) to Secure QUIC<br />
  <span class="filename">draft-thomson-quic-tls-latest</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>This document describes how Transport Layer Security (TLS) can be used to secure QUIC.</p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on November 25, 2016.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2016 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Notational Conventions</a></li>
</ul><li>2.   <a href="#rfc.section.2">Protocol Overview</a></li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Handshake Overview</a></li>
</ul><li>3.   <a href="#rfc.section.3">TLS in Stream 1</a></li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Handshake and Setup Sequence</a></li>
</ul><li>4.   <a href="#rfc.section.4">QUIC Record Protection</a></li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Key Phases</a></li>
<li>4.2.   <a href="#rfc.section.4.2">QUIC Key Expansion</a></li>
<li>4.3.   <a href="#rfc.section.4.3">QUIC AEAD application</a></li>
<li>4.4.   <a href="#rfc.section.4.4">Sequence Number Reconstruction</a></li>
</ul><li>5.   <a href="#rfc.section.5">Pre-handshake QUIC Messages</a></li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Unprotected Frames Prior to Handshake Completion</a></li>
<ul><li>5.1.1.   <a href="#rfc.section.5.1.1">STREAM Frames</a></li>
<li>5.1.2.   <a href="#rfc.section.5.1.2">ACK Frames</a></li>
<li>5.1.3.   <a href="#rfc.section.5.1.3">WINDOW_UPDATE Frames</a></li>
<li>5.1.4.   <a href="#rfc.section.5.1.4">FEC Packets</a></li>
<li>5.1.5.   <a href="#rfc.section.5.1.5">Denial of Service with Unprotected Packets</a></li>
</ul><li>5.2.   <a href="#rfc.section.5.2">Use of 0-RTT Keys</a></li>
<li>5.3.   <a href="#rfc.section.5.3">Protected Frames Prior to Handshake Completion</a></li>
</ul><li>6.   <a href="#rfc.section.6">QUIC-Specific Additions to the TLS Handshake</a></li>
<ul><li>6.1.   <a href="#rfc.section.6.1">Protocol and Version Negotiation</a></li>
<li>6.2.   <a href="#rfc.section.6.2">QUIC Extension</a></li>
<li>6.3.   <a href="#rfc.section.6.3">Source Address Validation</a></li>
<li>6.4.   <a href="#rfc.section.6.4">Packet Reflection Attack Mitigation</a></li>
</ul><li>7.   <a href="#rfc.section.7">Security Considerations</a></li>
<li>8.   <a href="#rfc.section.8">IANA Considerations</a></li>
<li>9.   <a href="#rfc.references">References</a></li>
<ul><li>9.1.   <a href="#rfc.references.1">Normative References</a></li>
<li>9.2.   <a href="#rfc.references.2">Informative References</a></li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Acknowledgments</a></li>
<li><a href="#rfc.authors">Authors' Addresses</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a></h1>
<p id="rfc.section.1.p.1">QUIC <a href="#I-D.tsvwg-quic-protocol">[I-D.tsvwg-quic-protocol]</a> provides a multiplexed transport for HTTP <a href="#RFC7230">[RFC7230]</a> semantics that provides several key advantages over HTTP/1.1 <a href="#RFC7230">[RFC7230]</a> or HTTP/2 <a href="#RFC7540">[RFC7540]</a> over TCP <a href="#RFC0793">[RFC0793]</a>.</p>
<p id="rfc.section.1.p.2">This document describes how QUIC can be secured using Transport Layer Security (TLS) version 1.3 <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a>.  TLS 1.3 provides critical latency improvements for connection establishment over previous versions.  Absent packet loss, most new connections can be established and secured within a single round trip; on subsequent connections between the same client and server, the client can often send application data immediately, that is, zero round trip setup.</p>
<p id="rfc.section.1.p.3">This document describes how the standardized TLS 1.3 can act a security component of QUIC.  The same design could work for TLS 1.2, though few of the benefits QUIC provides would be realized due to the handshake latency in versions of TLS prior to 1.3.</p>
<h2 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a> <a href="#notational-conventions" id="notational-conventions">Notational Conventions</a></h2>
<p id="rfc.section.1.1.p.1">The words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;SHOULD&#8221;, and &#8220;MAY&#8221; are used in this document.  It&#8217;s not shouting; when they are capitalized, they have the special meaning defined in <a href="#RFC2119">[RFC2119]</a>.</p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#protocol-overview" id="protocol-overview">Protocol Overview</a></h1>
<p id="rfc.section.2.p.1">QUIC <a href="#I-D.tsvwg-quic-protocol">[I-D.tsvwg-quic-protocol]</a> can be separated into several modules:</p>
<p/>

<ol>
  <li>The basic frame envelope describes the common packet layout.  This layer includes connection identification, version negotiation, and includes the indicators that allow the framing, public reset, and FEC modules to be identified.</li>
  <li>The public reset is an unprotected frame that allows an intermediary (an entity that is not part of the security context) to request the termination of a QUIC connection.</li>
  <li>The forward error correction (FEC) module provides redundant entropy that allows for frames to be repaired in event of loss.</li>
  <li>Framing comprises most of the QUIC protocol.  Framing provides a number of different types of frame, each with a specific purpose.  Framing supports frames for both congestion management and stream multiplexing.  Framing additionally provides a liveness testing capability (the PING frame).</li>
  <li>Encryption provides confidentiality and integrity protection for frames.  All frames are protected based on keying material derived from the TLS connection running on stream 1.  Prior to this, data is protected with the 0-RTT keys.</li>
  <li>Multiplexed streams are the primary payload of QUIC.  These provide reliable, in-order delivery of data and are used to carry the encryption handshake and transport parameters (stream 1), HTTP header fields (stream 3), and HTTP requests and responses.  Frames for managing multiplexing include those for creating and destroying streams as well as flow control and priority frames.</li>
  <li>Congestion management includes packet acknowledgment and other signal required to ensure effective use of available link capacity.</li>
  <li>A complete TLS connection is run on stream 1.  This includes the entire TLS record layer.  As the TLS connection reaches certain states, keying material is provided to the QUIC encryption layer for protecting the remainder of the QUIC traffic.</li>
  <li>HTTP mapping provides an adaptation to HTTP that is based on HTTP/2.</li>
</ol>
<p id="rfc.section.2.p.3">The relative relationship of these components are pictorally represented in <a href="#quic-structure">Figure 1</a>.</p>
<div id="rfc.figure.1"/>
<div id="quic-structure"/>
<pre>
   +-----+------+
   | TLS | HTTP |
   +-----+------+------------+
   |  Streams   | Congestion |
   +------------+------------+
   |        Frames           |
   +            +------------+
   |            |    FEC     +--------+
   +   +--------+------------+ Public |
   |   |     Encryption      | Reset  |
   +---+---------------------+--------+
   |              Envelope            |
   +----------------------------------+
   |                UDP               |
   +----------------------------------+
</pre>
<p class="figure">Figure 1: QUIC Structure</p>
<p id="rfc.section.2.p.4">This document defines the cryptographic parts of QUIC.  This includes the handshake messages that are exchanged on stream 1, plus the record protection that is used to encrypt and authenticate all other frames.</p>
<h2 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1.</a> <a href="#handshake-overview" id="handshake-overview">Handshake Overview</a></h2>
<p id="rfc.section.2.1.p.1">TLS 1.3 provides two basic handshake modes of interest to QUIC:</p>
<p/>

<ul>
  <li>A full handshake in which the client is able to send application data after one round trip and the server immediately after receiving the first message from the client.</li>
  <li>A 0-RTT handshake in which the client uses information about the server to send immediately.  This data can be replayed by an attacker so it MUST NOT carry a self-contained trigger for any non-idempotent action.</li>
</ul>
<p id="rfc.section.2.1.p.3">A simplified TLS 1.3 handshake with 0-RTT application data is shown in <a href="#tls-full">Figure 2</a>, see <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a> for more options and details.</p>
<div id="rfc.figure.2"/>
<div id="tls-full"/>
<pre>
    Client                                             Server

    ClientHello
   (Finished)
   (0-RTT Application Data)
   (end_of_early_data)        --------&gt;
                                                  ServerHello
                                         {EncryptedExtensions}
                                         {ServerConfiguration}
                                                 {Certificate}
                                           {CertificateVerify}
                                                    {Finished}
                             &lt;--------      [Application Data]
   {Finished}                --------&gt;

   [Application Data]        &lt;-------&gt;      [Application Data]
</pre>
<p class="figure">Figure 2: TLS Handshake with 0-RTT</p>
<p id="rfc.section.2.1.p.4">Two additional variations on this basic handshake exchange are relevant to this document:</p>
<p/>

<ul>
  <li>The server can respond to a ClientHello with a HelloRetryRequest, which adds an additional round trip prior to the basic exchange.  This is needed if the server wishes to request a different key exchange key from the client.  HelloRetryRequest is also used to verify that the client is correctly able to receive packets on the address it claims to have (see <a href="#source-address">Section 6.3</a>).</li>
  <li>A pre-shared key mode can be used for subsequent handshakes to avoid public key operations.  This is the basis for 0-RTT, even if the remainder of the connection is protected by a new Diffie-Hellman exchange.</li>
</ul>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#tls-in-stream-1" id="tls-in-stream-1">TLS in Stream 1</a></h1>
<p id="rfc.section.3.p.1">QUIC completes its cryptographic handshake on stream 1, which means that the negotiation of keying material happens after the QUIC protocol has started.  This simplifies the use of TLS since QUIC is able to ensure that the TLS handshake packets are delivered reliably and in order.</p>
<p id="rfc.section.3.p.2">QUIC Stream 1 carries a complete TLS connection.  This includes the TLS record layer in its entirety.  QUIC provides for reliable and in-order delivery of the TLS handshake messages on this stream.</p>
<p id="rfc.section.3.p.3">Prior to the completion of the TLS handshake, QUIC frames can be exchanged.  However, these frames are not authenticated or confidentiality protected.  <a href="#pre-handshake">Section 5</a> covers some of the implications of this design and limitations on QUIC operation during this phase.</p>
<p id="rfc.section.3.p.4">Once complete, QUIC frames and forward error control (FEC) messages are encapsulated in using TLS record protection.</p>
<h2 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a> <a href="#handshake-and-setup-sequence" id="handshake-and-setup-sequence">Handshake and Setup Sequence</a></h2>
<p id="rfc.section.3.1.p.1">The integration of QUIC with a TLS handshake is shown in more detail in <a href="#quic-tls-handshake">Figure 3</a>.  QUIC <samp>STREAM</samp> frames on stream 1 carry the TLS handshake.  QUIC is responsible for ensuring that the handshake packets are re-sent in case of loss and that they can be ordered correctly.</p>
<div id="rfc.figure.3"/>
<div id="quic-tls-handshake"/>
<pre>
    Client                                             Server

   QUIC STREAM Frame(s) &lt;1&gt;:
     ClientHello
       + QUIC Setup Parameters
                            --------&gt;
   ! 0-RTT Key Available

   (QUIC STREAM Frame(s) &lt;1&gt;:)
     (({Finished}))
   (Replayable QUIC Frames &lt;any stream&gt;)
                            --------&gt;
                                         0-RTT Key Available !

                                      (QUIC STREAM Frame &lt;1&gt;:)
                                               (ServerHello)
                                      ({Handshake Messages})
                            &lt;--------
                                         1-RTT Key Available !

                                             [QUIC Frames/FEC]
                            &lt;--------
   (QUIC STREAM Frame(s) &lt;1&gt;:)
     ((end_of_early_data &lt;1&gt;))
     ({Finished})
                            --------&gt;
   ! 1-RTT Key Available

   [QUIC Frames/FEC]        &lt;-------&gt;        [QUIC Frames/FEC]
</pre>
<p class="figure">Figure 3: QUIC over TLS Handshake</p>
<p id="rfc.section.3.1.p.2">In <a href="#quic-tls-handshake">Figure 3</a>, symbols mean:</p>
<p/>

<ul>
  <li>&#8221;&lt;&#8221; and &#8220;&gt;&#8221; enclose stream numbers.</li>
  <li>&#8221;!&#8221; indicates when keying material is available.</li>
  <li>&#8221;(&#8220; and &#8220;)&#8221; enclose messages that are protected with QUIC or TLS 0-RTT keys.  If 0-RTT is not possible, or not accepted, then regular frames protected by this keys are not sent by the client, and the server sends its handshake messages without protection.</li>
  <li>&#8221;{&#8220; and &#8220;}&#8221; enclose messages that are protected by the TLS Handshake keys. Note that the client&#8217;s 0-RTT Finished message is protected by the QUIC 0-RTT key, plus the TLS 0-RTT handshake key.</li>
  <li>&#8221;[&#8221; and &#8220;]&#8221; enclose messages that are protected by the QUIC 1-RTT keys.</li>
</ul>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#quic-record-protection" id="quic-record-protection">QUIC Record Protection</a></h1>
<p id="rfc.section.4.p.1">QUIC provides a record protection layer that is responsible for authenticated encryption of packets.  The record protection layer uses keys provided by the TLS connection and authenticated encryption to</p>
<p id="rfc.section.4.p.2">Different keys are used for QUIC and TLS record protection.  Having separate QUIC and TLS record protection means that TLS records can be protected by two different keys.  This redundancy is maintained for the sake of simplicity.</p>
<h2 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1.</a> <a href="#key-phases" id="key-phases">Key Phases</a></h2>
<p id="rfc.section.4.1.p.1">The transition to use of a new QUIC key occurs immediately after sending the TLS handshake messages that produced the key transition.  Every time that a new set of keys is used for protecting outbound messages, the KEY_PHASE bit in the public flags is toggled.  The KEY_PHASE bit on unencrypted messages is 0.</p>
<p id="rfc.section.4.1.p.2">The KEY_PHASE bit on the public flags is the most significant bit (0x80).</p>
<p id="rfc.section.4.1.p.3">The KEY_PHASE bit allows a recipient to detect a change in keying material without needing to receive the message that triggers the change.  This avoids head-of-line blocking around transitions between keys without relying on trial decryption.</p>
<p id="rfc.section.4.1.p.4">The following transitions are defined:</p>
<p/>

<ul>
  <li>The client transitions to using 0-RTT keys after sending the ClientHello.  This causes the KEY_PHASE bit on packets sent by the client to be set to 1.</li>
  <li>The server transitions to using 0-RTT keys before sending the ServerHello, but only if the early data from the client is accepted.  This transition causes the KEY_PHASE bit on packets sent by the server to be set to 1.  If the server rejects 0-RTT data, the server&#8217;s handshake messages are sent without QUIC-level record protection with a KEY_PHASE of 0.  TLS handshake messages will still be protected by TLS record protection based on the TLS handshake traffic keys.</li>
  <li>The server transitions to using 1-RTT keys after sending its Finished message.  This causes the KEY_PHASE bit to be set to 0 if early data was accepted, and 1 if the server rejected early data.</li>
  <li>The client transitions to 1-RTT keys after sending its Finished message.  Subsequent messages from the client will then have a KEY_PHASE of 0 if 0-RTT data was sent, and 1 otherwise.</li>
  <li>Both peers start sending messages protected by a new key immediately after sending a TLS KeyUpdate message. The value of the KEY_PHASE bit is changed each time.</li>
</ul>
<p id="rfc.section.4.1.p.6">At each point, both keying material (see <a href="#key-expansion">Section 4.2</a>) and the the AEAD function used by TLS is interchanged with the values that are currently in use for protecting outbound packets.  Once a change of keys has been made, packets with higher sequence numbers MUST use the new keying material until a newer set of keys (and AEAD) are used.</p>
<p id="rfc.section.4.1.p.7">Once a packet protected by a new key has been received, a recipient SHOULD retain the previous keys for a short period.  Retaining old keys allows the recipient to decode reordered packets around a change in keys.  Keys SHOULD be discarded when an endpoints has received all packets with sequence numbers lower than the lowest sequence number used for the new key, or when it determines that reordering of those packets is unlikely.</p>
<p id="rfc.section.4.1.p.8">The KEY_PHASE bit does not indicate which keys are in use.  Depending on whether 0-RTT data was sent and accepted, packets protected with keys derived from the same secret might be marked with different KEY_PHASE values.</p>
<p id="rfc.section.4.1.p.9">Once the TLS handshake is complete, the KEY_PHASE bit allows for the processing of messages without having to receive the TLS KeyUpdate message that triggers the key update.  As required by TLS, only one key update can be in progress at a time and each peer cannot initiate a new key update until it has received a matching KeyUpdate message.  This ensures that a peer cannot initiate two consecutive updates, which could be undetectable based on the KEY_PHASE bit.</p>
<h2 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2.</a> <a href="#key-expansion" id="key-expansion">QUIC Key Expansion</a></h2>
<p id="rfc.section.4.2.p.1">The following table shows QUIC keys, when they are generated and the TLS secret from which they are derived:</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <thead>
    <tr>
      <th class="left">Key</th>
      <th class="left">TLS Secret</th>
      <th class="left">Phase</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="left">0-RTT</td>
      <td class="left">early_traffic_secret</td>
      <td class="left">&#8220;QUIC 0-RTT key expansion&#8221;</td>
    </tr>
    <tr>
      <td class="left">1-RTT</td>
      <td class="left">traffic_secret_N</td>
      <td class="left">&#8220;QUIC 1-RTT key expansion&#8221;</td>
    </tr>
  </tbody>
</table>
<p id="rfc.section.4.2.p.2">0-RTT keys are those keys that are used in resumed connections prior to the TLS handshake completes.  Data sent using 0-RTT keys might be replayed and so has some restructions on its use, see <a href="#using-early-data">Section 5.2</a>.  0-RTT keys are used after sending or receiving a ClientHello.</p>
<p id="rfc.section.4.2.p.3">1-RTT keys are used after the handshake completes.  There are potentially multiple sets of 1-RTT keys; new 1-RTT keys are created by sending a TLS KeyUpdate message.  1-RTT keys are used after sending a Finished or KeyUpdate message.</p>
<p id="rfc.section.4.2.p.4">The complete key expansion uses the same process for key expansion as defined in Section 7.3 of <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a>.  For example, the Client Write Key for the data sent immediately after sending the TLS Finished message is:</p>
<pre>
   label = "QUIC 1-RTT key expansion, client write key"
   client_write = HKDF-Expand-Label(traffic_secret_0, label,
                                    "", key_length)
</pre>
<p id="rfc.section.4.2.p.5">The QUIC record protection initially starts without keying material.  When the TLS state machine produces the corresponding secret, new keys are generated from the TLS connection and used to protect the QUIC record protection.</p>
<p id="rfc.section.4.2.p.6">The Authentication Encryption with Associated Data (AEAD) <a href="#RFC5116">[RFC5116]</a> function used is the one used by the TLS connection.  For example, if TLS is using the TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, the AEAD_AES_128_GCM function is used.</p>
<h2 id="rfc.section.4.3"><a href="#rfc.section.4.3">4.3.</a> <a href="#quic-aead-application" id="quic-aead-application">QUIC AEAD application</a></h2>
<p id="rfc.section.4.3.p.1">Regular QUIC packets are protected by an AEAD <a href="#RFC5116">[RFC5116]</a>.  Version negotiation and public reset packets are not protected.</p>
<p id="rfc.section.4.3.p.2">Once TLS has provided a key, the contents of regular QUIC packets, starting immediately after the packet number are protected by the AEAD selected by TLS.</p>
<p id="rfc.section.4.3.p.3">The key, K, for the AEAD is either the Client Write Key or the Server Write Key, derived as defined in <a href="#key-expansion">Section 4.2</a>.</p>
<p id="rfc.section.4.3.p.4">The nonce, N, for the AEAD is formed by combining either the Client Write IV or Server Write IV with the sequence numbers.  The 48 bits of the reconstructed QUIC sequence number (see <a href="#seq-num">Section 4.4</a>) in network byte order is left-padded with zeros to the N_MAX parameter of the AEAD (see Section 4 of <a href="#RFC5116">[RFC5116]</a>).  The exclusive OR of the padded sequence number and the IV forms the AEAD nonce.</p>
<p id="rfc.section.4.3.p.5">The associated data, A, for the AEAD is an empty sequence.</p>
<p id="rfc.section.4.3.p.6">The input plaintext, P, for the AEAD is the contents of the QUIC frame following the packet number, as described in <a href="#I-D.tsvwg-quic-protocol">[I-D.tsvwg-quic-protocol]</a>.</p>
<p id="rfc.section.4.3.p.7">The output ciphertext, C, of the AEAD is transmitted in place of P.</p>
<p id="rfc.section.4.3.p.8">Prior to TLS providing keys, no record protection is performed and the plaintext, P, is transmitted unmodified.</p>
<p/>

<dl>
  <dt>Note:</dt>
  <dd style="margin-left: 8">QUIC defined a null-encryption that had an additional, hash-based checksum for cleartext packets.  This might be added here, but it is more complex.</dd>
</dl>
<h2 id="rfc.section.4.4"><a href="#rfc.section.4.4">4.4.</a> <a href="#seq-num" id="seq-num">Sequence Number Reconstruction</a></h2>
<p id="rfc.section.4.4.p.1">Each peer maintains a 48-bit sequence number that is incremented with every packet that is sent, including retransmissions.  The least significant 8-, 16-, 32-, or 48-bits of this number is encoded in the QUIC sequence number field in every packet.</p>
<p id="rfc.section.4.4.p.2">A receiver maintains the same values, but recovers values based on the packets it receives.  This is based on the sequence number of packets that it has received.  A simple scheme predicts the receive sequence number of an incoming packet by incrementing the sequence number of the most recent packet to be successfully decrypted by one and expecting the sequence number to be within a range centered on that value.</p>
<p id="rfc.section.4.4.p.3">A more sophisticated algorithm can almost double the search space by checking backwards from the most recent sequence for a received (or abandoned) packet.  If a packet was received, then the packet contains a sequence number that is greater than the most recent sequence number.  If no such packet was found, the number is assumed to be in the smaller window centered on the next sequence number, as in the simpler scheme.</p>
<p/>

<dl>
  <dt>Note:</dt>
  <dd style="margin-left: 8">QUIC has a single, contiguous sequence number space.  In comparison, TLS restarts its sequence number each time that record protection keys are changed.  The sequence number restart in TLS ensures that a compromise of the current traffic keys does not allow an attacker to truncate the data that is sent after a key update by sending additional packets under the old key (causing new packets to be discarded).  QUIC does not assume a reliable transport and is therefore required to handle attacks where packets are dropped in other ways.  TLS maintains a separate sequence number that is used for record protection on the connection that is hosted on stream 1.  This sequence number is reset according to the rules in the TLS protocol.</dd>
</dl>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#pre-handshake" id="pre-handshake">Pre-handshake QUIC Messages</a></h1>
<p id="rfc.section.5.p.1">Implementations MUST NOT exchange data on any stream other than stream 1 prior to the completion of the TLS handshake.  However, QUIC requires the use of several types of frame for managing loss detection and recovery.  In addition, it might be useful to use the data acquired during the exchange of unauthenticated messages for congestion management.</p>
<p id="rfc.section.5.p.2">The actions that a peer takes as a result of receiving an unauthenticated packet needs tobe limited.  In particular, state established by these packets cannot be retained once record protection commences.</p>
<p id="rfc.section.5.p.3">There are several approaches possible for dealing with unauthenticated packets prior to handshake completion:</p>
<p/>

<ul>
  <li>discard and ignore them</li>
  <li>use them, but reset any state that is established once the handshake completes</li>
  <li>use them and authenticate them afterwards; failing the handshake if they can&#8217;t be authenticated</li>
  <li>save them and use them when they can be properly authenticated</li>
  <li>treat them as a fatal error</li>
</ul>
<p id="rfc.section.5.p.5">Different strategies are appropriate for different types of data.  This document proposes that all strategies are possible depending on the type of message.</p>
<p/>

<ul>
  <li>Transport parameters and options are made usable and authenticated as part of the TLS handshake (see <a href="#quic_parameters">Section 6.2</a>).</li>
  <li>Most unprotected messages are treated as fatal errors when received except for the small number necessary to permit the handshake to complete (see <a href="#pre-handshake-unprotected">Section 5.1</a>).</li>
  <li>Protected packets can either be discarded or saved and later used (see <a href="#pre-handshake-protected">Section 5.3</a>).</li>
</ul>
<h2 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1.</a> <a href="#pre-handshake-unprotected" id="pre-handshake-unprotected">Unprotected Frames Prior to Handshake Completion</a></h2>
<p id="rfc.section.5.1.p.1">This section describes the handling of messages that are sent and received prior to the completion of the TLS handshake.</p>
<p id="rfc.section.5.1.p.2">Sending and receiving unprotected messages is hazardous.  Unless expressly permitted, receipt of an unprotected message of any kind MUST be treated as a fatal error.</p>
<h3 id="rfc.section.5.1.1"><a href="#rfc.section.5.1.1">5.1.1.</a> <a href="#stream-frames" id="stream-frames">STREAM Frames</a></h3>
<p><samp>STREAM</samp> frames for stream 1 are permitted.  These carry the TLS handshake messages.</p>
<p id="rfc.section.5.1.1.p.2">Receiving unprotected <samp>STREAM</samp> frames or unprotected <samp>STREAM</samp> frames for other streams MUST be treated as a fatal error.</p>
<p/>

<dl>
  <dt>Issue:</dt>
  <dd style="margin-left: 8">Is it possible to send a <samp>STREAM</samp> frame for stream 1 that contains no data? Is this detectable?  Does it comprise an attack?  For instance, could an attacker inject a frame that appears to contain TLS application data?</dd>
</dl>
<h3 id="rfc.section.5.1.2"><a href="#rfc.section.5.1.2">5.1.2.</a> <a href="#ack-frames" id="ack-frames">ACK Frames</a></h3>
<p><samp>ACK</samp> frames are permitted prior to the handshake being complete.  However, an unauthenticated <samp>ACK</samp> frame can only be used to obtain NACK ranges.  Timestamps MUST NOT be included in an unprotected ACK frame, since these might be modified by an attacker with the intent of altering congestion control response.  Information on FEC-revived packets is redundant, since use of FEC in this phase is prohibited.</p>
<p><samp>ACK</samp> frames MAY be sent a second time once record protection is enabled.  Once protected, timestamps can be included.</p>
<p/>

<dl>
  <dt>Editor&#8217;s Note:</dt>
  <dd style="margin-left: 8">This prohibition might be a little too strong, but this is the only obviously safe option.  If the amount of damage that an attacker can do by modifying timestamps is limited, then it might be OK to permit the inclusion of timestamps.  Note that an attacker need not be on-path to inject an ACK.</dd>
</dl>
<h3 id="rfc.section.5.1.3"><a href="#rfc.section.5.1.3">5.1.3.</a> <a href="#windowupdate-frames" id="windowupdate-frames">WINDOW_UPDATE Frames</a></h3>
<p><samp>WINDOW_UPDATE</samp> frames MUST NOT be sent unprotected.</p>
<p id="rfc.section.5.1.3.p.2">Though data is exchanged on stream 1, the initial flow control window is is sufficiently large to allow the TLS handshake to complete.  However, this limits the maximum size of the TLS handshake.  This is unlikely to cause issues unless a server or client provides an abnormally large certificate chain.</p>
<p id="rfc.section.5.1.3.p.3">Stream 1 is exempt from the connection-level flow control window.</p>
<h3 id="rfc.section.5.1.4"><a href="#rfc.section.5.1.4">5.1.4.</a> <a href="#fec-packets" id="fec-packets">FEC Packets</a></h3>
<p id="rfc.section.5.1.4.p.1">FEC packets MUST NOT be sent prior to completing the TLS handshake.  Endpoints MUST treat receipt of an unprotected FEC packet as a fatal error.</p>
<h3 id="rfc.section.5.1.5"><a href="#rfc.section.5.1.5">5.1.5.</a> <a href="#denial-of-service-with-unprotected-packets" id="denial-of-service-with-unprotected-packets">Denial of Service with Unprotected Packets</a></h3>
<p id="rfc.section.5.1.5.p.1">Accepting unprotected - specifically unauthenticated - packets presents a denial of service risk to endpoints.  An attacker that is able to inject unprotected packets can cause a recipient to drop even protected packets with a matching sequence number.  Given the restrictions on unprotected packets, the following options are available:</p>
<p/>

<ul>
  <li><samp>ACK</samp> packets can be spoofed and might be processed by a recipient.  ACK packets will cause the recipient of the <samp>ACK</samp> to - perhaps falsely - believe that their messages have been received when they have not.</li>
  <li>Spoofed <samp>ACK</samp> packets that have no effect on the state of a recipient still consume a sequence number, one that might be used by legitimate packets.  This causes the recipient to drop the legitimate packet, which might result in a request for a retransmission.</li>
  <li>Spoofed <samp>STREAM</samp> packets need to be on stream 1 for an endpoint to accept them.  These either contain new data or they contain a retransmission of data that has already been received (is this permitted without an <samp>ACK</samp>?).  An implementation might accept empty TLS records without altering the TLS state machine.  <br/><br/> To that end, a TLS implementation MUST reject empty TLS handshake records and any record that is not permitted by the TLS state machine.  Any TLS application data or alerts - other than a single end_of_early_data at the appropriate time - that is received prior to the end of the handshake MUST be treated as a fatal error.</li>
</ul>
<p id="rfc.section.5.1.5.p.3">Once an encrypted packet has been accepted, unprotected packets MUST be dropped if they have a higher sequence number than the encrypted packet.</p>
<p id="rfc.section.5.1.5.p.4">As a result, an attacker that intends to deny service to an endpoint has to drop protected packets in order to ensure that their victim continues to accept unprotected packets.  This means that an attacker has to be on-path for this to be effective, at which point they are better served by dropping the packets that they don&#8217;t wish the recipient to receive.</p>
<h2 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2.</a> <a href="#using-early-data" id="using-early-data">Use of 0-RTT Keys</a></h2>
<p id="rfc.section.5.2.p.1">If 0-RTT keys are available, the lack of replay protection means that restrictions on their use are necessary to avoid replay attacks on the protocol.</p>
<p id="rfc.section.5.2.p.2">A client MUST only use 0-RTT keys for the protection of data that is idempotent.  A client MAY wish to apply additional restrictions on what data it sends prior to the completion of the TLS handshake.  A client otherwise treats 0-RTT keys as equivalent to 1-RTT keys.</p>
<p id="rfc.section.5.2.p.3">A client that has successfully used 0-RTT keys can send 0-RTT data until it receives all of the server&#8217;s handshake messages.  A client SHOULD stop sending 0-RTT data if it receives an indication that 0-RTT data has been rejected.  In addition to a ServerHello without an early_data extension, an unprotected handshake message with a KEY_PHASE bit set to 0 indicates that 0-RTT data has been rejected.</p>
<p id="rfc.section.5.2.p.4">A client SHOULD therefore send its end_of_early_data alert after it has either received all of the server&#8217;s handshake messages, or it receives an unprotected handshake message.  Alternatively phrased, a client is encouraged to use 0-RTT keys until 1-RTT keys become available.  This prevents stalling of the connection and allows the client to send continuously.</p>
<p id="rfc.section.5.2.p.5">A server MUST NOT use 0-RTT keys for anything other than TLS handshake messages.  Servers therefore treat packets protected with 0-RTT keys as equivalent to unprotected packets in determining what can be sent.  A server protects handshake messages using the 0-RTT key if it decides to accept a 0-RTT key.  A server MUST still include the early_data extension in its handshake.</p>
<p id="rfc.section.5.2.p.6">This prevents a server from responding to a request using 0-RTT.  This ensures that all application data from the server enjoy forward secrecy protection.  However, this results in head-of-line blocking at the client because server responses cannot be decrypted until all the server&#8217;s handshake messages are received.</p>
<h2 id="rfc.section.5.3"><a href="#rfc.section.5.3">5.3.</a> <a href="#pre-handshake-protected" id="pre-handshake-protected">Protected Frames Prior to Handshake Completion</a></h2>
<p id="rfc.section.5.3.p.1">Due to reordering and loss, protected packets might be received by an endpoint before the final handshake messages are received.  If these can be decrypted successfully, such packets MAY be stored and used once the handshake is complete.</p>
<p id="rfc.section.5.3.p.2">Unless expressly permitted below, encrypted packets MUST NOT be used prior to completing the TLS handshake, in particular the receipt of a valid Finished message and any authentication of the peer.  If packets are processed prior to completion of the handshake, an attacker might use the willingness of an implementation to use these packets to mount attacks.</p>
<p id="rfc.section.5.3.p.3">TLS handshake messages are covered by record protection during the handshake, once key agreement has completed.  This means that protected messages need to be decrypted to determine if they are TLS handshake messages or not.  Similarly, <samp>ACK</samp> and <samp>WINDOW_UPDATE</samp> frames might be needed to successfully complete the TLS handshake.</p>
<p id="rfc.section.5.3.p.4">Any timestamps present in <samp>ACK</samp> frames MUST be ignored rather than causing a fatal error.  Timestamps on protected frames MAY be saved and used once the TLS handshake completes successfully.</p>
<p id="rfc.section.5.3.p.5">An endpoint MAY save the last protected <samp>WINDOW_UPDATE</samp> frame it receives for each stream and apply the values once the TLS handshake completes.  Failing to do this might result in temporary stalling of affected streams.</p>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#quic-specific-additions-to-the-tls-handshake" id="quic-specific-additions-to-the-tls-handshake">QUIC-Specific Additions to the TLS Handshake</a></h1>
<p id="rfc.section.6.p.1">QUIC uses the TLS handshake for more than just negotiation of cryptographic parameters.  The TLS handshake validates protocol version selection, provides preliminary values for QUIC transport parameters, and allows a server to perform return routeability checks on clients.</p>
<h2 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1.</a> <a href="#version-negotiation" id="version-negotiation">Protocol and Version Negotiation</a></h2>
<p id="rfc.section.6.1.p.1">The QUIC version negotiation mechanism is used to negotiate the version of QUIC that is used prior to the completion of the handshake.  However, this packet is not authenticated, enabling an active attacker to force a version downgrade.</p>
<p id="rfc.section.6.1.p.2">To ensure that a QUIC version downgrade is not forced by an attacker, version information is copied into the TLS handshake, which provides integrity protection for the QUIC negotiation.  This does not prevent version downgrade during the handshake, though it means that such a downgrade causes a handshake failure.</p>
<p/>

<dl>
  <dt>TBD:</dt>
  <dd style="margin-left: 8">Determine whether we are using ALPN or a new quic_version extension and describe that fully.</dd>
</dl>
<h2 id="rfc.section.6.2"><a href="#rfc.section.6.2">6.2.</a> <a href="#quic_parameters" id="quic_parameters">QUIC Extension</a></h2>
<p id="rfc.section.6.2.p.1">QUIC defines an extension for use with TLS.  That extension defines transport-related parameters.  This provides integrity protection for these values.  Including these in the TLS handshake also make the values that a client sets available to a server one-round trip earlier than parameters that are carried in QUIC frames.  This document does not define that extension.</p>
<h2 id="rfc.section.6.3"><a href="#rfc.section.6.3">6.3.</a> <a href="#source-address" id="source-address">Source Address Validation</a></h2>
<p id="rfc.section.6.3.p.1">QUIC implementations describe a source address token.  This is an opaque blob that a server might provide to clients when they first use a given source address.  The client returns this token in subsequent messages as a return routeability check.  That is, the client returns this token to prove that it is able to receive packets at the source address that it claims.  This prevents the server from being used in packet reflection attacks.</p>
<p id="rfc.section.6.3.p.2">A source address token is opaque and consumed only by the server.  Therefore it can be included in the TLS 1.3 pre-shared key identifier for 0-RTT handshakes.  Servers that use 0-RTT are advised to provide new pre-shared key identifiers after every handshake to avoid linkability of connections by passive observers.  Clients MUST use a new pre-shared key identifier for every connection that they initiate; if no pre-shared key identifier is available, then resumption is not possible.</p>
<p id="rfc.section.6.3.p.3">A server that is under load might include a source address token in the cookie extension of a HelloRetryRequest. (Note: the current version of TLS 1.3 does not include the ability to include a cookie in HelloRetryRequest.)</p>
<h2 id="rfc.section.6.4"><a href="#rfc.section.6.4">6.4.</a> <a href="#packet-reflection-attack-mitigation" id="packet-reflection-attack-mitigation">Packet Reflection Attack Mitigation</a></h2>
<p id="rfc.section.6.4.p.1">A small ClientHello that results in a large block of handshake messages from a server can be used in packet reflection attacks to amplify the traffic generated by an attacker.</p>
<p id="rfc.section.6.4.p.2">Certificate caching <a href="#I-D.ietf-tls-cached-info">[I-D.ietf-tls-cached-info]</a> can reduce the size of the server&#8217;s handshake messages significantly.</p>
<p id="rfc.section.6.4.p.3">A client SHOULD also pad <a href="#RFC7685">[RFC7685]</a> its ClientHello to at least 1024 octets (TBD: tune this value).  A server is less likely to generate a packet reflection attack if the data it sends is a small multiple of the data it receives.  A server SHOULD use a HelloRetryRequest if the size of the handshake messages it sends is likely to exceed the size of the ClientHello.</p>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a></h1>
<p id="rfc.section.7.p.1">There are likely to be some real clangers here eventually, but the current set of issues is well captured in the relevant sections of the main text.</p>
<p id="rfc.section.7.p.2">Never assume that because it isn&#8217;t in the security considerations section it doesn&#8217;t affect security.  Most of this document does.</p>
<h1 id="rfc.section.8"><a href="#rfc.section.8">8.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a></h1>
<p id="rfc.section.8.p.1">This document has no IANA actions.  Yet.</p>
<h1 id="rfc.references"><a href="#rfc.references">9.</a> References</h1>
<h2 id="rfc.references.1"><a href="#rfc.references.1">9.1.</a> Normative References</h2>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a>, "<a href="http://tools.ietf.org/html/draft-ietf-tls-tls13-12">The Transport Layer Security (TLS) Protocol Version 1.3</a>", Internet-Draft draft-ietf-tls-tls13-12, March 2016.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.tsvwg-quic-protocol">[I-D.tsvwg-quic-protocol]</b>
      </td>
      <td class="top"><a>Hamilton, R.</a>, <a>Iyengar, J.</a>, <a>Swett, I.</a> and <a>A. Wilk</a>, "<a href="http://tools.ietf.org/html/draft-tsvwg-quic-protocol-02">QUIC: A UDP-Based Secure and Reliable Transport for HTTP/2</a>", Internet-Draft draft-tsvwg-quic-protocol-02, January 2016.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a>Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5116">[RFC5116]</b>
      </td>
      <td class="top"><a>McGrew, D.</a>, "<a href="http://tools.ietf.org/html/rfc5116">An Interface and Algorithms for Authenticated Encryption</a>", RFC 5116, DOI 10.17487/RFC5116, January 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7301">[RFC7301]</b>
      </td>
      <td class="top"><a>Friedl, S.</a>, <a>Popov, A.</a>, <a>Langley, A.</a> and <a>E. Stephan</a>, "<a href="http://tools.ietf.org/html/rfc7301">Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension</a>", RFC 7301, DOI 10.17487/RFC7301, July 2014.</td>
    </tr>
  </tbody>
</table>
<h2 id="rfc.references.2"><a href="#rfc.references.2">9.2.</a> Informative References</h2>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-tls-cached-info">[I-D.ietf-tls-cached-info]</b>
      </td>
      <td class="top"><a>Santesson, S.</a> and <a>H. Tschofenig</a>, "<a href="http://tools.ietf.org/html/draft-ietf-tls-cached-info-23">Transport Layer Security (TLS) Cached Information Extension</a>", Internet-Draft draft-ietf-tls-cached-info-23, May 2016.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC0793">[RFC0793]</b>
      </td>
      <td class="top"><a>Postel, J.</a>, "<a href="http://tools.ietf.org/html/rfc793">Transmission Control Protocol</a>", STD 7, RFC 793, DOI 10.17487/RFC0793, September 1981.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7230">[RFC7230]</b>
      </td>
      <td class="top"><a>Fielding, R.</a> and <a>J. Reschke</a>, "<a href="http://tools.ietf.org/html/rfc7230">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>", RFC 7230, DOI 10.17487/RFC7230, June 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7258">[RFC7258]</b>
      </td>
      <td class="top"><a>Farrell, S.</a> and <a>H. Tschofenig</a>, "<a href="http://tools.ietf.org/html/rfc7258">Pervasive Monitoring Is an Attack</a>", BCP 188, RFC 7258, DOI 10.17487/RFC7258, May 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7540">[RFC7540]</b>
      </td>
      <td class="top"><a>Belshe, M.</a>, <a>Peon, R.</a> and <a>M. Thomson</a>, "<a href="http://tools.ietf.org/html/rfc7540">Hypertext Transfer Protocol Version 2 (HTTP/2)</a>", RFC 7540, DOI 10.17487/RFC7540, May 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7685">[RFC7685]</b>
      </td>
      <td class="top"><a>Langley, A.</a>, "<a href="http://tools.ietf.org/html/rfc7685">A Transport Layer Security (TLS) ClientHello Padding Extension</a>", RFC 7685, DOI 10.17487/RFC7685, October 2015.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.appendix.A"><a href="#rfc.appendix.A">Appendix A.</a> <a href="#acknowledgments" id="acknowledgments">Acknowledgments</a></h1>
<p id="rfc.section.A.p.1">Christian Huitema&#8217;s knowledge of QUIC is far better than my own.  This would be even more inaccurate and useless if not for his assistance.  This document has variously benefited from a long series of discussions with Jana Iyengar, Adam Langley, Roberto Peon, Eric Rescorla, Ian Swett, and likely many others who are merely forgotten by a faulty meat computer.</p>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Authors' Addresses</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Martin Thomson</span> 
	  <span class="n hidden">
		<span class="family-name">Thomson</span>
	  </span>
	</span>
	<span class="org vcardline">Mozilla</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:martin.thomson@gmail.com">martin.thomson@gmail.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Ryan Hamilton</span> 
	  <span class="n hidden">
		<span class="family-name">Hamilton</span>
	  </span>
	</span>
	<span class="org vcardline">Google</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:rch@google.com">rch@google.com</a></span>

  </address>
</div>

  <div class="github-fork-ribbon-wrapper"><div class="github-fork-ribbon"><a href="https://github.com/martinthomson/quic-tls">Fork me on GitHub</a></div></div>
</body>
</html>
